/*
TemplateFox API

Generate beautiful PDFs from HTML/CSS templates with Jinja2 via API. Design once, generate thousands.

API version: 1.1.1.dev2+gfe6303fdd.d20260209
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package templatefox

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


type IntegrationsAPI interface {

	/*
	DeleteS3Config Delete S3 configuration

	Delete S3 storage configuration.

**Authentication:** API Key required (`x-api-key` header)

**Usage:** Remove your S3 integration. Generated PDFs will use the default CDN storage after deletion.

**Warning:** This action is irreversible. You'll need to reconfigure S3 to use it again.

**No credits consumed:** This is a configuration endpoint.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return IntegrationsAPIDeleteS3ConfigRequest
	*/
	DeleteS3Config(ctx context.Context) IntegrationsAPIDeleteS3ConfigRequest

	// DeleteS3ConfigExecute executes the request
	//  @return S3SuccessResponse
	DeleteS3ConfigExecute(r IntegrationsAPIDeleteS3ConfigRequest) (*S3SuccessResponse, *http.Response, error)

	/*
	GetS3Config Get S3 configuration

	Get current S3 storage configuration.

**Authentication:** API Key required (`x-api-key` header)

**Usage:** Retrieve your S3 integration settings. Secret access key is masked for security.

**Returns 404** if S3 is not configured.

**No credits consumed:** This is a read-only endpoint.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return IntegrationsAPIGetS3ConfigRequest
	*/
	GetS3Config(ctx context.Context) IntegrationsAPIGetS3ConfigRequest

	// GetS3ConfigExecute executes the request
	//  @return S3ConfigResponse
	GetS3ConfigExecute(r IntegrationsAPIGetS3ConfigRequest) (*S3ConfigResponse, *http.Response, error)

	/*
	SaveS3Config Save S3 configuration

	Save or update S3-compatible storage configuration.

**Authentication:** API Key required (`x-api-key` header)

**Usage:** Configure your S3-compatible storage to receive generated PDFs directly
in your own bucket instead of the default CDN.

**Supported providers:**
- Amazon S3
- DigitalOcean Spaces
- Cloudflare R2
- MinIO
- Any S3-compatible storage

**Secret key behavior:**
- For new configuration: `secret_access_key` is required
- For updates: Omit `secret_access_key` to keep existing value

**No credits consumed:** This is a configuration endpoint.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return IntegrationsAPISaveS3ConfigRequest
	*/
	SaveS3Config(ctx context.Context) IntegrationsAPISaveS3ConfigRequest

	// SaveS3ConfigExecute executes the request
	//  @return S3SuccessResponse
	SaveS3ConfigExecute(r IntegrationsAPISaveS3ConfigRequest) (*S3SuccessResponse, *http.Response, error)

	/*
	TestS3Connection Test S3 connection

	Test S3 connection with stored credentials.

**Authentication:** API Key required (`x-api-key` header)

**Usage:** Verify your S3 configuration is working correctly. The test will:
1. Connect to the endpoint
2. Verify bucket access
3. Check write permissions by uploading a small test file

**Prerequisite:** S3 must be configured first using `POST /v1/integrations/s3`

**No credits consumed:** This is a diagnostic endpoint.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return IntegrationsAPITestS3ConnectionRequest
	*/
	TestS3Connection(ctx context.Context) IntegrationsAPITestS3ConnectionRequest

	// TestS3ConnectionExecute executes the request
	//  @return S3TestResponse
	TestS3ConnectionExecute(r IntegrationsAPITestS3ConnectionRequest) (*S3TestResponse, *http.Response, error)
}

// IntegrationsAPIService IntegrationsAPI service
type IntegrationsAPIService service

type IntegrationsAPIDeleteS3ConfigRequest struct {
	ctx context.Context
	ApiService IntegrationsAPI
}

func (r IntegrationsAPIDeleteS3ConfigRequest) Execute() (*S3SuccessResponse, *http.Response, error) {
	return r.ApiService.DeleteS3ConfigExecute(r)
}

/*
DeleteS3Config Delete S3 configuration

Delete S3 storage configuration.

**Authentication:** API Key required (`x-api-key` header)

**Usage:** Remove your S3 integration. Generated PDFs will use the default CDN storage after deletion.

**Warning:** This action is irreversible. You'll need to reconfigure S3 to use it again.

**No credits consumed:** This is a configuration endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return IntegrationsAPIDeleteS3ConfigRequest
*/
func (a *IntegrationsAPIService) DeleteS3Config(ctx context.Context) IntegrationsAPIDeleteS3ConfigRequest {
	return IntegrationsAPIDeleteS3ConfigRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return S3SuccessResponse
func (a *IntegrationsAPIService) DeleteS3ConfigExecute(r IntegrationsAPIDeleteS3ConfigRequest) (*S3SuccessResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *S3SuccessResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsAPIService.DeleteS3Config")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/integrations/s3"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type IntegrationsAPIGetS3ConfigRequest struct {
	ctx context.Context
	ApiService IntegrationsAPI
}

func (r IntegrationsAPIGetS3ConfigRequest) Execute() (*S3ConfigResponse, *http.Response, error) {
	return r.ApiService.GetS3ConfigExecute(r)
}

/*
GetS3Config Get S3 configuration

Get current S3 storage configuration.

**Authentication:** API Key required (`x-api-key` header)

**Usage:** Retrieve your S3 integration settings. Secret access key is masked for security.

**Returns 404** if S3 is not configured.

**No credits consumed:** This is a read-only endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return IntegrationsAPIGetS3ConfigRequest
*/
func (a *IntegrationsAPIService) GetS3Config(ctx context.Context) IntegrationsAPIGetS3ConfigRequest {
	return IntegrationsAPIGetS3ConfigRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return S3ConfigResponse
func (a *IntegrationsAPIService) GetS3ConfigExecute(r IntegrationsAPIGetS3ConfigRequest) (*S3ConfigResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *S3ConfigResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsAPIService.GetS3Config")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/integrations/s3"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type IntegrationsAPISaveS3ConfigRequest struct {
	ctx context.Context
	ApiService IntegrationsAPI
	s3ConfigRequest *S3ConfigRequest
}

func (r IntegrationsAPISaveS3ConfigRequest) S3ConfigRequest(s3ConfigRequest S3ConfigRequest) IntegrationsAPISaveS3ConfigRequest {
	r.s3ConfigRequest = &s3ConfigRequest
	return r
}

func (r IntegrationsAPISaveS3ConfigRequest) Execute() (*S3SuccessResponse, *http.Response, error) {
	return r.ApiService.SaveS3ConfigExecute(r)
}

/*
SaveS3Config Save S3 configuration

Save or update S3-compatible storage configuration.

**Authentication:** API Key required (`x-api-key` header)

**Usage:** Configure your S3-compatible storage to receive generated PDFs directly
in your own bucket instead of the default CDN.

**Supported providers:**
- Amazon S3
- DigitalOcean Spaces
- Cloudflare R2
- MinIO
- Any S3-compatible storage

**Secret key behavior:**
- For new configuration: `secret_access_key` is required
- For updates: Omit `secret_access_key` to keep existing value

**No credits consumed:** This is a configuration endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return IntegrationsAPISaveS3ConfigRequest
*/
func (a *IntegrationsAPIService) SaveS3Config(ctx context.Context) IntegrationsAPISaveS3ConfigRequest {
	return IntegrationsAPISaveS3ConfigRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return S3SuccessResponse
func (a *IntegrationsAPIService) SaveS3ConfigExecute(r IntegrationsAPISaveS3ConfigRequest) (*S3SuccessResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *S3SuccessResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsAPIService.SaveS3Config")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/integrations/s3"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.s3ConfigRequest == nil {
		return localVarReturnValue, nil, reportError("s3ConfigRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.s3ConfigRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type IntegrationsAPITestS3ConnectionRequest struct {
	ctx context.Context
	ApiService IntegrationsAPI
}

func (r IntegrationsAPITestS3ConnectionRequest) Execute() (*S3TestResponse, *http.Response, error) {
	return r.ApiService.TestS3ConnectionExecute(r)
}

/*
TestS3Connection Test S3 connection

Test S3 connection with stored credentials.

**Authentication:** API Key required (`x-api-key` header)

**Usage:** Verify your S3 configuration is working correctly. The test will:
1. Connect to the endpoint
2. Verify bucket access
3. Check write permissions by uploading a small test file

**Prerequisite:** S3 must be configured first using `POST /v1/integrations/s3`

**No credits consumed:** This is a diagnostic endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return IntegrationsAPITestS3ConnectionRequest
*/
func (a *IntegrationsAPIService) TestS3Connection(ctx context.Context) IntegrationsAPITestS3ConnectionRequest {
	return IntegrationsAPITestS3ConnectionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return S3TestResponse
func (a *IntegrationsAPIService) TestS3ConnectionExecute(r IntegrationsAPITestS3ConnectionRequest) (*S3TestResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *S3TestResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsAPIService.TestS3Connection")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/integrations/s3/test"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
